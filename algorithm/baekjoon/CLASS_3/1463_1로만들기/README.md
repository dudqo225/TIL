# Algorithm | 백준 1463.1로 만들기 (python)

> 본 문제의 저작권은 BAEKJOON에 있습니다.
>
> [백준 1463.1로 만들기 링크](https://www.acmicpc.net/problem/1463)

</br>

#### 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

</br>

#### 입력

첫째 줄에 1보다 크거나 같고, $$10^6$$ 보다 작거나 같은 정수 N이 주어진다.

</br>

#### 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

</br>

#### 코드

```python
N = int(input())

dp_list = [0, 0, 1, 1]

for i in range(4, N+1):
    dp_list.append(dp_list[i-1] + 1)

    if i % 2 == 0:
        dp_list[i] = min(dp_list[i], dp_list[i//2] + 1)

    if i % 3 == 0:
        dp_list[i] = min(dp_list[i], dp_list[i//3] + 1)

print(dp_list[N])
```

</br>

#### 풀이

```python
동적계획법. Dynamic Programming. DP 알고리즘으로 문제를 해결한다.

DP란?
큰 문제를 작은 문제로 단순화시켜 해겷하는 알고리즘이다. 주어진 문제를 잘게 나누어서 하위 문제들을 푼 이후, 하위 문제 답들을 이용하여 주어진 문제를 푸는 방식이다.
DP 문제를 풀 때는 '점화식' 을 세우면 문제를 쉽게 해결할 수 있다.

문제에서 10을 예시로 들어보면, 10은 2로 나누어떨어지지만
1) 10 → 5 → 4 → 2 → 1 (총 4번)
2) 10 → 9 → 3 → 1 (총 3번)
2번과 같이 연산했을 때 연산 횟수가 최소가 된다. 2번 방식으로 구할 때,
9가 1이되는 최소 횟수를 알고 있다면 (9가 1이 되는 최소 횟수) + (10에서 1을 빼서 9로 가는 횟수) 로 답을 구할 수 있다.

어떠한 수 N에 대해서 연산이 최소가 되는 경우를 알고 싶다면 아래와 같은 점화식을 만들 수 있다.

dp_list[N] = min(dp_list[N-1], dp_list[N//2], dp_list[N//3]) + 1

먼저 dp_list에 0 ~ 3까지 최소 횟수를 저장한다.
i를 4부터 N까지 반복하면서 1) 1을 뺀 경우의 수 저장 2) 2로 나누어떨어질 경우 최소값 비교 3) 3으로 나누어떨어질 경우 최소값 비교 를 진행한다.
반복문 종료 이후 dp_list의 N번째 값을 결과로 출력한다.
```



#### 참고

https://kangmin1012.tistory.com/34

https://seohyun0120.tistory.com/entry/%EB%B0%B1%EC%A4%80-1463-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-%ED%92%80%EC%9D%B4-Dynamic-Programming-python-%ED%8C%8C%EC%9D%B4%EC%8D%AC

https://infinitt.tistory.com/247

https://jae04099.tistory.com/entry/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%B0%B1%EC%A4%80-1463-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0



✨ CLASS 3 문제가 훨씬 어려운 건지, 아니면 내가 쫄아서 어렵게 느끼는건지 모르겠다. DP 에 대해서 다양한 문제를 풀어봤지만 다시한번 공부하고 연습해야겠다고 생각했다. 역시 알고리즘은 어려워...🤣 2022.01.03

