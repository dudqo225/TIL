# Algorithm | 백준 1929.소수 구하기 (python)

> 본 문제의 저작권은 BAEKJOON에 있습니다.
>
> [백준 1929.소수 구하기 링크](https://www.acmicpc.net/problem/1929)

</br>

#### 문제

M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.

</br>

#### 코드

```python
def prime_list(m, n):
    sieve = [True] * (n+1)
    if m == 1:
        sieve[1] = False

    for i in range(2, int(n**0.5)+1):
        if sieve[i] == True:
            for j in range(i+i, n+1, i):
                sieve[j] = False
    return [i for i in range(m, n+1) if sieve[i] == True]

M, N = map(int, input().split())

ans = prime_list(M, N)

for a in ans:
    print(a)
```

</br>

#### 풀이

```python
s1 코드는 주어진 자연수 M부터 N까지 자연수에 대해서 소수를 판별하는 함수를 구현하였다. 자연수 x를 2부터 x-1까지 증가시키면서 그 수로 나누어 떨어지면 소수가 아니고 반복문이 정상적으로 종료되면 소수인 것으로 판별하였다. 하지만 결과는 '시간초과'...

구글링을 해서 '에라토스테네스의 체' 알고리즘을 찾았다.
에라토스테네스의 체란?
임의의 자연수 n에 대해서 그 이하의 소수를 찾는 가장 간단하고 빠른 방법이다.

구현 방법
<기본>
1. 1부터 자연수 100까지 나열한다.
2. 소수도, 합성수도 아닌 유일한 자연수 1을 제거한다.
3. 2를 제외한 2의 배수를 제거한다.
4. 3을 제외한 3의 배수를 제거한다.
5. 4의 배수는 지울 필요 없다. (3번 2의 배수에서 이미 지워졌다). 2, 3 다음 가장 작은 소수 5를 제외한 5의 배수를 제거한다.
6. 7을 제외한 7의 배수를 제거한다.
7. 8, 9, 10의 배수는 지울 필요 없다. (이미 이전 단계에서 지워졌기 때문)
8. 11 이상의 소수들의 배수도 지울 필요 없다 → 11 > 100**0.5(100의 제곱근) 이기 때문에 지울 필요가 없다. 자연수 100의 최대 약수가 sqrt(100) 이하이므로!  
```



##### 참고

[티스토리 블로그](https://kbwplace.tistory.com/76)

[위키피디아 글](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)

[나무위키](https://namu.wiki/w/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%20%EC%B2%B4)



✨ 입력받는 단일 자연수가 소수인지 판별하는 문제는 쉽게 풀 수 있다. 하지만 이 문제와 같이 자연수 범위가 주어지고 그 사이의 소수를 출력하는 문제는 '시간초과' 때문에 어렵게 느껴졌다. 에라토스테네스의 체라는 알고리즘을 하나 배웠다!!! 2021.12.25

