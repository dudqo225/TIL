# Algorithm | 백준 11866.요세푸스 문제 0 (python)

> 본 문제의 저작권은 BAEKJOON에 있습니다.
>
> [백준 11866.요세푸스 문제 0 링크](https://www.acmicpc.net/problem/11866)

</br>

#### 문제

요세푸스 문제는 다음과 같다.

1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.

N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.

</br>

#### 코드

```python
from collections import deque

N, K = map(int, input().split())

Q = deque()
ans = []

for i in range(1, N+1):
    Q.append(i)

while Q:
    for i in range(K-1):
        Q.append(Q[0])
        Q.popleft()
    ans.append(Q.popleft())

print('<', end='')
for i in range(len(ans)-1):
    print('{}, '.format(ans[i]), end='')
print('{}>'.format(ans[-1]))
```

</br>

#### 풀이

```python
요세푸스 순열의 원리는 '원'을 이루는 것에 초점이 있다. '원'의 사람이 모두 제거될때까지 원을 순환하는 로직을 생각해야 한다.

1. K번째 사람을 만날때까지 0번, 1번, 2번... k-1번 사람을 뽑아서 '원'의 뒤에 붙인다.
2. K번째 사람을 만나면 그 사람은 ans 리스트에 저장한다.
3. '원'에 남아있는 사람이 없어서 while문이 종료되면, 결과를 출력한다.

초기에는 일반 list()를 사용하여 코드를 구현하였으나 시간초과 에러가 나타났다. 따라서 파이썬 내장 collections의 deque를 활용하여 시간 단축을 하였다. s1.py 파일은 거의 하드코딩식으로 작성하여 테스트 케이스에 대한 정답은 구했으나, 시간초과의 문제도 있고 코드자체가 너무 복잡한 문제가 있다.
```



#### 참고

- https://hongcoding.tistory.com/41
- https://pacific-ocean.tistory.com/233

블로그 글 모두 `deque` 를 활용하여 문제를 해결하였다.



✨ 리스트, 배열을 활용해야 하는 알고리즘 문제는 `deque`를 사용하는 것을 먼저 고려해야겠다. 나중에 난이도가 높은 문제에서는 내장 라이브러리의 사용이 제한될 수 있지만 아직까지 내가 푸는 수준의 문제는 내장 함수나 라이브러리를 사용해서 문제를 풀어내는 것이 우선순위인 것 같다.

또한, `s1.py` 파일에서 테스트 케이스에 대한 문제 해결은 완료하였으나, 나머지 TC에 대한 시간초과 문제와 더불어 코드가 하드코딩된 것 같은 느낌이 든다. 문제를 푸는 방식에 대해서는 어느정도 생각이 났고 구현하였으나, 좀더 간결하고 모든 TC에 적용할만한 클린코드를 구현하는 것을 더 연습하자!
