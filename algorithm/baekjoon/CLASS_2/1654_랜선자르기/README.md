# Algorithm | 백준 1654.랜선 자르기 (python)

> 본 문제의 저작권은 BAEKJOON에 있습니다.
>
> [백준 1654.랜선 자르기 링크](https://www.acmicpc.net/problem/1654)

</br>

#### 문제

집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.

이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)

편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.

</br>

#### 코드

```python
K, N = map(int, input().split())

cables = []

for _ in range(K):
    cable = int(input())
    cables.append(cable)

start = 1
end = max(cables)
ans = 0

while start <= end:
    cnt = 0

    mid = (start + end) // 2

    for cable in cables:
        if cable >= mid:
            cnt += cable // mid

    if cnt >= N:
        start = mid + 1
        ans = mid
    else:
        end = mid - 1

print(ans)
```

</br>

#### 풀이

```python
'이진탐색'으로 문제를 해결한다. 숫자를 단순히 1씩 증가하면서 결과 탐색을 하면 시간 초과 오류가 나올 수 있기때문이다.

최대 랜선의 길이를 구해야 하므로, 초기값은 0이 아닌 1로 설정하고 종료값을 입력받은 랜선 중 최대값으로 설정한다.

'이진탐색' 기본 문법을 적용하여, start(초기값)이 end(종료값) 보다 작거나 같을 동안 while문을 반복한다. 반복할 때마다 cnt를 0으로 초기화하고, 초기값과 종료값의 중간값인 mid를 설정한다. 입력받은 랜선 리스트를 순회하면서 각각의 랜선(cable)을 mid로 나눈 값 즉, 랜선의 개수를 cnt에 더하여 준다.
for문을 종료한 뒤, 랜선의 개수 cnt가 N보다 크거나 같으면 문제의 조건을 만족하므로 정답 ans 변수에 mid 값을 할당한다. 그리고 start(초기값)을 mid+1로 바꾸어준다. 만일 cnt가 N보다 작으면 end(종료값)을 mid-1로 바꾸어준다. 이후 while문을 다시 반복하면서 ans의 최대값을 찾아간다.
while문이 종료된 후 ans를 출력한다.
```



##### 참고

https://claude-u.tistory.com/443

https://jiwon-coding.tistory.com/116

https://chancoding.tistory.com/58



✨ 이진탐색 문제를 다시한번 풀어보았다. 처음에 구현한 코드는 채점 30%까지 잘 가다가 틀린코드로 결과가 나왔다. 조건, 코드를 다시 살피다가 start 값을 0으로 설정한 것을 찾았다. 랜선이기 때문에 초기값이 0이 아닌 1이어야 한다. 그외에는 기본적인 이진탐색 문법을 적용하여 해답을 찾았다. 단순히 mid를 출력하기 보다는, 조건을 만족한 mid 값을 ans에 저장하고 탐색을 계속하면서 최대값을 찾는 것이 더 논리적으로 맞는 것 같다. 굳!!! 2021.12.30

