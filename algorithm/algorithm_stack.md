# Algorithm | Stack

### 목차

> - 스택
> - 재귀호출
> - Memoization
> - DP
> - DFS

</br></br>

### 1. 스택

#### 스택(Stack)의 특성

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
- 스택에 저장된 자료는 선형 구조를 갖는다
  - 선형 구조 : 자료 간 관계가 1대1
  - 비선형 구조 : 자료 간 관계가 1대N (ex. 트리)
- 스택에 자료를 삽입(`push`)하거나 꺼낼(`pop`) 수 있다.
- 마지막에 삽입한 자료를 먼저 꺼낸다.
  - **`후입선출(LIFO, Last-In-First-Out)`**
- *1차원 배열을 사용하여 스택을 구현할 경우*
  - **구현이 용이**하다는 장점이 있다.
  - **but**, 스택의 크기를 변경하기 어렵다
  - 이를 해결하기 위해, 저장소를 동적으로 할당하여 스택 구현 가능
    - `동적 연결리스트` 를 이용하여 구현
    - 구현이 복잡하지만, 메모리를 효율적으로 사용할 수 있음

<br>

#### 스택 구현을 위한 자료구조 & 연산

- 자료 구조
  - **배열** 을 사용
  - 저장소 자체를 스택이라고 부르기도 함
  - 스택에서 마지막 삽입된 원소의 위치를 `top` 이라고 부른다
- 연산
  - `삽입` : 저장소에 자료를 저장. `push` 라고도 함
  - `삭제` : 저장소에서 자료를 꺼낸다. `pop` 이라고 함
  - `isEmpty` : 스택이 공백인지 아닌지 확인하는 연산
  - `peek` : 스택의 top에 있는 item(원소) 을 반환하는 연산

<br>

##### Function call

- 프로그램에서 함수 호출 및 복귀에 따른 수행 순서를 관리
  - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀 → 후입선출 구조
  - 함수 호출이 발생하면
    - 지역변수, 매개변수, 수행 후 복귀할 주소 등의 정보를 Stack frame에 저장해서 시스템 스택에 삽입
    - 실행이 끝나면 시스템 스택의 top 원소를 삭제하면서 frame에 저장되어 있던 복귀 주소를 확인하고 복귀
  - 함수의 호출 & 복귀에 따라 위 과정을 반복하여 전체 프로그램이 수행이 종료되면 시스템 스택은 공백 스택이 된다.

<br>

### 2. 재귀호출

#### 재귀호출

- 자기 자신을 호출하여 순환 수행되는 것

- 재귀호출 방식을 사용해서 함수를 만들면 프로그램 크기를 줄이고 간단하게 작성할 수 있다

- 예시

  - `factorial`

  - `피보나치 수열`

    ```python
    def fibo(n):
        if n < 2:
            return n
        else:
            return fibo(n-1) + fibo(n-2)
    ```

- **But, 엄청난 중복 호출이 존재**한다.

<br>

### 3. Memoization

- 메모이제이션(memoization) 이란
  - 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 실행속도를 빠르게 하는 기술
  - 동적 계획법의 핵심
- **= to put in memory. 메모리에 넣기**

```python
# 피보나치 수열
## 재귀함수로 구현시 Θ(2ⁿ)

## Memoization 적용
### memo를 위한 배열을 할당하고 0으로 초기화.
memo = [0, 1]

def fibo(n):
    global memo
    if n >= 2 and len(memo) <= n:
        memo.append(fibo(n-1) + fibo(n-2))
    return memo[n]
```

<br>

### 4. DP (Dynamic Programming)

- 동적 계획 알고리즘은 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘
- 입력 크기가 작은 부분 문제들을 모두 해결한 후, 그 해들을 이용해서 큰 크기의 부분 문제들을 해결 → 원래 주어진 입력의 문제를 해결하는 알고리즘

```python
# 피보나치 수열
## DP 적용 알고리즘
def fibo(n):
    f = [0, 1]
    
    for i in range(2, n+1):
        f.append(f[i-1] + f[i-2])
    
    return f[n]
```

- memoization을 재귀적 구조(recursive)에 사용하는 것보다 반복적 구조(iterative)로 DP를 구현한 것이 성능 면에서 효율적
  - 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문

<br>

### 5. DFS (깊이우선탐색)

- 비선형구조인 그래프 구조는 모든 자료를 빠짐없이 검색하는 것이 중요
  - **깊이 우선 탐색(Depth First Search, DFS)**
  - **너비 우선 탐색(Breadth First Search, BFS)**

#### DFS

- 시작 노드의 한 방향으로 갈 수 있는 경로 끝까지 깊이 탐색하다가 더 이상 갈 곳이 없으면,
- 가장 마지막에 만났던 갈림길 간선이 있는 노드로 되돌아와서 다른 방향의 노드로 탐색을 반복하면서
- 모든 정점을 방문하는 순회 방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 탐색을 반복해야 하므로 **후입선출** 구조의 스택 사용

```python
# DFS 알고리즘
visited[], stack[] 초기화
DFS(v)
	v 방문;
    visited[v] ← True;
    do {
        if (v의 인접 정점 중 방문 안한 w 찾기)
        	push(v);
        while( w ) {
            w 방문;
            visited[w] ← True;
            push(w);
            v ← w;
            v의 인접 정점 중 방문 안한 w 찾기
        }
        v ← pop(stack);
    } while(v)
end DFS()
```

