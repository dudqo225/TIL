# CS | Data Structures - Tree

### Tree 트리

- 트리란?
  - `node` 로 이루어진 자료 구조 (node면 리스트..?)
- 특징
  - 트리는 하나의 `root node` 를 갖는다.
  - `root node` 는 0개 이상의 자식 노드를 갖고 있다.
  - 그 자식 노드 또한 0개의 자식 노드를 가지고 있고, 이것이 반복적으로 정의된다.
  - 사이클(cycle) 이 존재할 수 없다
  - 특정 순서로 나열될 수도 / 아닐 수도 있다
  - 부모 노드로의 연결이 있을 수도 / 없을 수도 있다
  - 각 노드는 어떤 자료형으로도 표현이 가능하다
  - 비선형 자료구조로 **계층적 관계**를 표현
- 구성
  - `node` 와 `edge`
  - 노드와 노드를 연결하는 간선으로 구성되어 있음

- 그래프와의 관계
  - 그래프의 한 종류이다.
  - Cycle 이 없는 하나의 연결 그래프(Connected Graph) 이다
  - DAG (Directed Acyclic Graph) - 방향성이 있는 비순환 그래프의 한 종류

</br></br>

#### 용어

- Root Node : 부모가 없는 노드. 트리는 단 하나의 루트 노드를 가진다
- Leaf Node : 자식이 없는 노드. 단말 / 잎 / 말단 노드라고도 부른다
- Internal Node : 내부노드. leaf node가 아닌 노드
- Edge : 간선. 노드를 연결하는 선. link / branch 라고도 부른다
- Sibling :  형제. 같은 부모를 가지는 노드
- Size : 노드의 크기. 자신을 포함한 모든 자손 노드의 갯수
- Depth : 노드의 깊이. 루트 노드에서 특정 노드에 도달하기 위해 거쳐야 하는 간선의 수
- Level : 노드의 레벨. 트리의 특정 깊이를 가지는 노드들의 집합
- Degree : 노드의 차수. 하위 트리 개수 / 간선 수 → 각 노드가 지닌 가지의 수
- Degree of Tree : 트리의 차수. 트리의 최대 차수
- Height : 트리의 높이. 루트 노드에서 가장 깊숙하게 있는 노드의 깊이

</br></br>

#### 특징

- 노드가 N개인 트리는 항상 N-1개의 edge를 가진다
- 두 노드 사이에는 반드시 1개의 경로. edge만 있다
- 모든 자식 노드는 하나의 부모 노드만을 가진다
- 흐름은 top-bottom 혹은 bottom-top 으로 이루어진다.
- 순회 방법
  - Pre-order
  - In-order
  - Post-order
  - 위 세가지 모두 DFS / BFS 안에 있다
- 종류
  - 이진 트리
  - 이진 탐색 트리
  - 균형 트리 (AVL 트리, red-black 트리)
  - 이진 힙 (최대힙, 최소힙)
  - etc

</br></br>

### 트리의 종류

##### Binary Tree 이진 트리

- 각 노드가 최대 두개의 자식을 갖는 트리
- 순회 방법
  - 중위 순회 (in-order traversal) : 왼쪽 가지 > 현재 노드 > 오른쪽 가지
  - 전위 순회 (pre-order traversal) : 현재 노드 > 왼쪽 가지 > 오른쪽 가지
  - 후위 순회 (post-order traversal) : 왼쪽 가지 > 오른쪽 가지 > 현재 노드



##### Binary Search Tree 이진 탐색 트리

- 모든 노드가 아래와 같은 특정 순서를 따르는 이진 트리
- `모든 왼쪽 자식 노드 <= n < 모든 오른쪽 자식노드`

</br></br>

##### 균형 트리 & 비균형 트리

- 균형 트리
  - O(logN) 시간에 insert와 find를 할 수 있을 정도로 균형이 잘 잡혀 있는 경우
  - ex. red-black 트리, AVL 트리

</br></br>

##### 완전 / 전 / 포화 이진 트리

- 완전 이진 트리 (Complete Binary Tree)
  - 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있는 트리
  - 모든 높이에서 노드가 꽉 차 있다
  - 마지막 레벨은 꽉 차있지 않아도 되며, 노드가 왼쪽에서 오른쪽으로 채워져야 한다
- 전 이진 트리 (full Binary Tree / Strictly Binary Tree)
  - 모든 노드가 0개 or 2개의 자식 노드를 갖는 트리

- 포화 이진 트리 (Perfect Binary Tree)
  - 전 이진 트리이면서 완전 이진 트리인 경우
  - 모든 leaf 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 함
  - 모든 내부 노드가 2개의 자식 노드를 가진다
  - 모든 leaf 노드가 동일한 깊이, 레벨을 가진다
  - 노드의 개수가 정확히 2^(k-1)개여야 함 (k는 트리의 높이)

![img](Data_Structures_Tree.assets/tree-types-example.png)

</br></br>

##### 이진 힙 (최소힙과 최대힙)

- 힙 (Heap) 이란?
  - 최대값, 최소값을 찾아내는 연산을 쉽게하기 위해 고안된 자료형
  - 우선순위 큐를 위하여 만들어진 자료구조

- 최소힙 (Min Heap)
  - 트리 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 모두 채워져 있는 완전 이진 트리
  - 각 노드의 원소가 자식들의 원소보다 작다
  - key (부모노드) >= key (자식노드)인 완전 이진 트리
  - 가장 큰 값은 root node
  - N개가 힙에 들어가 있으면 높이는 log(N)
- 최대힙 (Max Heap)
  - 원소가 내림차순으로 정렬되어 있음
  - 각 노드의 원소가 자식들의 원소보다 크다

![img](Data_Structures_Tree.assets/types-of-heap.png)

</br></br>

##### 트라이 (Trie)

- 접두사 트리  (prefix tree) 라고도 함
- n-차 트리의 변형
- 각 노드에 `문자` 를 저장하는 자료 구조
- 트리를 아래쪽으로 순회하면 단어가 하나 나온다
- **접두사를 빠르게 찾기 위한 방식**으로, 모든 언어를 트라이에 저장해놓는 방식이 있음
- **유효한 단어 집합을 이용**하는 문제는 트라이를 통해 최적화할 수 있다

</br></br>

### 트리 구현 방법

- 트리는 그래프의 한 종류이므로 그래프 구현 방법(인접 리스트 or 인접 배열)으로 구현할 수 있다.
- 인접 배열 이용
  - 1차원 배열에 자신의 부모 노드만 저장하는 방법
  - 이진트리의 경우, 2차원 배열에 자식 노드를 저장하는 방법
    - A\[i][o]: 왼쪽 자식 노드, A\[i][1]: 오른쪽 자식 노드
- 인접 리스트 이용
  - 가중치가 없는 트리
    - `ArrayList<ArrayList>  list = new ArrayList<>();`
  - 가중치가 있는 트리
    - `class Node { int num, dist; // 노드 번호, 거리}`
    - `ArrayList[] list = new ArrayList[정점 수 + 1]`





> 무슨 말인지 진짜 하나도 모르겠지만, 나중에 트리를 배우고 다시 한 번 보자.
>
> 2021.08.06
