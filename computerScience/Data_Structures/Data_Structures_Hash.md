# CS | Data Structures - Hash

### Hash 해시

- 해시란?
  - 데이터를 다루는 기법 중 하나
  - 해시 함수 (Hash Function) 는 데이터의 효율적인 관리를 목적으로, **임의 길이의 데이터를 고정된 길이의 데이터로 매핑**하는 함수
  - 매핑 전 원래 데이터 값을 키(Key), 매핑 후 데이터 값을 해시값(Hash value) or 해시 코드라고 한다.
  - 매핑하는 과정 자체를 해싱(hashing) 이라고 한다.
  - 두 해시 값이 다르면 원래의 데이터 값도 다르다.
  - 하지만 같은 해시값을 가지고 있더라도 원래 데이터가 꼭 같은 것도 아니다.
  - 해시 함수 종류
    - MD1, MD4, MD5, SHS, SHA-1, HAS-160 등

</br></br>

#### 해시 테이블 (Hash Table)

- 빠르게 데이터를 검색할 수 있는 자료구조

- 효율적인 탐색을 위해 (key, value) 로 데이터를 저장

- 검색속도가 빠른 이유는 내부적으로 배열(버킷)을 사용해서 데이터를 저장하기 때문

- 구현 방법

  - 해시 함수로 해시 코드를 계산
  - `해시값 % array_length` 와 같이 배열의 인덱스를 구한다.
  - 배열의 각 인덱스에 key-value 로 이루어진 연결리스트를 선언한다. 고유한 인덱스 값이 설정됨.
  - 서로 다른 두개의 키가 같은 해시코드를 가리키거나 / 서로 다른 두개의 해시코드가 같은 인덱스를 가리키는 경우 `충돌(collision)` 이 발생하는데,
  - 충돌 문제 해결을 위해 충돌을 줄여주는 좋은 해시 함수를 사용하는 것이 좋다.
  - `Separting Chaining`  또는 `Open addressing` 을 사용.

  ```
  원래 데이터 값(Key) → Hash Function → Hash Fuction의 결과 = Hash Code
  → Hash Code를 배열의 Index로 사용 → 해당하는 Index에 Data 넣기
  ```

- 충돌이 자주 발생한다면, 최악의 경우 수행시간은 `O(N)` 이 된다 (N = 키의 개수)

- 일반적으로 충돌을 최소화하도록 잘 구현된 경우 **평균 시간복잡도는 `O(1)`** 이다.

![img](Data_Structures_Hash.assets/img.png)

- 장점
  - 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있다.
    - HDD, Cloud 에 존재하는 많은 데이터들을 유한한 해시 값으로 매핑하여 작은 크기의 캐시 메모리로 프로세스 관리가 가능하다.
  - 배열의 index 를 사용해서 검색, 삽입, 삭제가 빠르다 (평균 시간 복잡도 : `O(1)`)
    - 인덱스를 사용하기 때문에 검색이 빠른 것은 당연.
    - 인덱스는 데이터만의 고유한 위치이기 때문에 삽입이나 삭제를 하더라도 다른 데이터로 채울 필요가 없다.
  - 키와 해시값이 연관성이 없어 **보안**에 많이 사용된다
  - 데이터 캐싱 (Data Caching) 에 많이 사용된다.
    - get(key), put(key) 에 캐시 로직을 추가하면 자주 hit 하는 데이터를 바로 찾을 수 있다.
  - 중복을 제거하는데 유용하다.
- 단점
  - 충돌이 발생
  - 공간 복잡도가 커진다
  - 순서가 있는 배열에 어울리지 않다.
  - 해시 함수 의존도가 높아진다

</br></br>

##### 해시 함수 (Hash)

- Division Method
  - 나눗셈을 사용하는 방법
  - 입력값을 테이블 크기로 나누어 계산 (주소 = 입력값 % 테이블 크기)
  - 테이블 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다
- Digit Folding
  - 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내 주소로 사용하는 방법
- Multiplication Method
  - 숫자로된 Key 값 k와 0과 1 사이의 실수 A, 2의 제곱수 m 을 사용하여 다음과 같이 계산한다.
  - `h(k) = (kAmod1) x m`
- Univeral Hashing
  - 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해서 해시값을 만드는 기법

</br></br>

##### Chaining

- 해시값이 충돌하는 경우 분리 연결법(Separate Chaining)과 개방 주소법(Open Addressing) 으로 해결
- Separate Chaining
  - 동일한 버킷의 데이터에 대해서 자료구조(Linked List)를 활용해 추가 메모리를 사용하여 데이터 주소를 저장하는 것
  - 해시 테이블의 확장이 필요없고 구현이 간단하며, 손쉽게 삭제할 수 있는 장점이 있다
  - 데이터 수가 많아지면 동일한 버킷에 chaining 되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소하는 단점이 있다
- Open Addressing
  - 비어있는 해시 테이블의 공간을 활용하는 방법
    - Linear Probing : 현재 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색하고 비어있는 버킷에 데이터를 저장하는 방법
    - Quadratic Probing : 해시의 저장순서 폭을 제곱으로 저장하는 방식. 처음 충돌이 발생한 경우 1만큼 이동하고 그다음 2², 2³ 칸씩 옮기는 방식
    - Double Hashing Probing : 해시된 값을 한번 더 해싱해서 규칙성을 없애버리는 방식. 두 번 해싱해서 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 해야 한다.

</br></br>

#### 해시 테이블 vs 해시 맵

- Java 에서 HashTable 과 HashMap 의 차이는 동기화 지원 여부이다.
- key 에 대한 hash 값을 사용해서 값을 저장하고 조회하는 것은 동일하다.
- 해시 테이블
  - 병렬 처리를 할 때 (동기화를 고려해야 하는 상황)
  - Null 값을 허용하지 않는다
- 해시 맵
  - 병렬 처리를 하지 않을 때 (동기화를 고려하지 않는 상황)
  - Null 값을 허용한다.

</br></br>

#### 참고

> https://developside.tistory.com/92
>
> https://mangkyu.tistory.com/102
>
> https://baeharam.github.io/posts/data-structure/hash-table/